import util from './util';

export default Object.assign({}, makeTagFunctions(
    'h1', 'h2', 'h3', 'h4', 'h5',
    'td', 'th', 'td', 'tr', 'table',
    'a', 'img',
    'div', 'span', 'button', 'p',
    'ul', 'li', 'ol',
    'textarea',
), {
    tag,
});

function makeTagFunctions(...tags) {
    const tagFunctions = {};    
    for (const tagName of tags) {
        tagFunctions[tagName] = (init) => tag(tagName, init);
    }
    return tagFunctions;
}

function tag(name, init) {
    return new Tag(name, init);
}

class Tag {
    constructor(name, init) {
        if (typeof init === 'string') {
            var str = init;
            init = { text: str };
        }

        this.name = name;
        this.refNames = [];

        if (Array.isArray(init)) {
            var children = init;
            init = { children: children };
        }
        this.init = init || {};
        this.__type = 'Tag';

        this.class = function (cls) {
            this.attrs.class = cls;
            return this;
        };
    }

    addRefName(name, isID) {
        this.refNames.push([name, isID]);
    }
    
    updateRefs() {
        for (const refo of this.refNames) {
            const refName = refo[0];
            const isID = refo[1];

            if (!isID) {
                if (!Array.isArray(this.refs[refName])) {
                    this.refs[refName] = [];
                }

                this.refs[refName].push(this.node);
            } else {
                this.refs[refName] = this.node;
            }
        }
    };

    loadInit() {
        this.children = this.init.children || [];

        this.refs = this.init.refs || {};

        if (this.init.id != null) {
            this.addRefName(this.init.id, true);
        }
        const classNames = typeof(this.init.class) === 'string' ? this.init.class.replace('  ', ' ').split(' ') : [];
        if (classNames.length > 0) {
            for (const className of classNames) {
                this.addRefName(className, false);
            }
        }

        if (this.init.ref) {
            this.addRefName(this.init.ref, true);
        }
        
        this.attrs = this.init.attrs || {};
        
        this.text = this.init.text || null;

        this.attrs.style = '';
        this.attrs.href = this.init.href || null;        
        this.attrs.id = this.init.id || null;
        this.attrs.class = this.init.class || '';

        return this;
    }

    extend(otherInit) {
        util.mergeInits(this.init, otherInit);
    }

    valOf(val) {
        if (typeof val === 'function') {
            return val.bind(this)();
        }
        return val;
    }

    add(tag) {
        this.children.push(tag);
        return this;
    }

    id(id) {
        this.attrs.id = id;
        return this;
    }

    addClass(cls) {
        this.attrs.class += ' ' + cls;
        return this;
    }

    addStyle(style) {
        this.attrs.style += '; ' + style;
        return this;
    }

    set(prop, val) {
        this.attrs[prop] = val;
        return this;
    }

    style(css) {
        this.attrs.style = css;
        return this;
    }

    render() {
        function mergeRefs(refs1, refs2) {
            var keys = Object.keys(refs2);
            for (var i=0; i<keys.length; ++i) {
                var key = keys[i];
                var ref = refs2[key];
                
                if (refs1[key] != null) {
                    if (Array.isArray(refs1[key])) {
                        refs1[key] = refs1[key].concat(ref);
                    } else {
                        refs1[key] = ref; // override using this ref instead of otherref
                    }
                } else {
                    refs1[key] = ref;
                }
            }
        }
        
        this.loadInit();
        var tag = document.createElement(this.name);
        tag.innerHTML = this.valOf(this.text);


        if (typeof this.init.style === 'object') {
            for (const key in this.init.style) {
                tag.style[key] = this.init.style[key];
            }
        } else if (typeof this.init.style === 'string') {
            this.attrs.style = this.init.style;
        }

        for (const key in this.attrs) {
            var val = this.attrs[key];
            if (val !== null && val !== '') {
                tag.setAttribute(key, this.valOf(val));
            }
        }
        
        for (const child of this.children) {
            let html;
            if (child.__type === 'Tag') {
                html = child.render();
            } else {
                html = child.render();
            }
            tag.appendChild(html);
            mergeRefs(this.refs, child.refs);                        
        }

        // problem, this function returns html whereas the components return a tag
        
        // these are needed (things to propogate to the tag): could probably be moved somewhere else tho

        for (const key in this.init) {
            if (key !== 'this' && key !== 'rows' && key !== 'children' && key !== 'style') { // should produce error message for illegal attributes on DOM nodes like "rows"
                tag[key] = this.init[key];
            }
        }
        
        this.node = tag;
        this.updateRefs();

        tag.refs = this.refs;

        return tag;
    };
}

